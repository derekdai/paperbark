#!/bin/bash

# $1: path ov vdev (image)
# $2: pool name
pool_create() {
    sudo zpool create -m legacy \
        -o ashift=12 \
        -O compression=on \
        "$2" "$1"

    sudo zfs create "$2/SNAPSHOTS"
    sudo zfs create "$2/STAGINGS"
}

# $1: pool name
pool_destroy() {
    sudo zpool destroy "$1"
}

# $1: pool name
pool_is_active() {
    sudo zpool list -H -o name "$1" &>/dev/null
}

# $1: image directory
# $2: pool name
pool_import() {
    sudo zpool import -d "$1" $2 &>/dev/null
}

# $1: directory to search for pool
pool_activate() {
    local _pool_file=($1/*.zfs)
    if [[ ! -f "$_pool_file" ]]; then
        return 1
    fi

    _zfs_pool_name="${_pool_file##*/}"
    _zfs_pool_name="${_zfs_pool_name%.zfs}"
    _zfs_ds_snapshots="$_zfs_pool_name/SNAPSHOTS"
    _zfs_ds_stagings="$_zfs_pool_name/STAGINGS"

    if ! pool_is_active "$_zfs_pool_name"; then
        if ! pool_import "$1" "$_zfs_pool_name"; then
            pool_create ""
        fi
    fi

    zfs_cache_init

}

dataset_exists() {
    zfs list -H -o name "$1" &>/dev/null
}

dataset_create() {
    zfs create -o mountpoint=legacy -p "$1"
}

# $1: dataset name
# $2: mount point
dataset_mount() {
    local _dataset="$1"; shift
    local _mount_point="$1"; shift
    mount -t zfs "$_dataset" "$_mount_point" "$@"
}

dataset_destroy() {
    zfs destroy -f "$1"
}

dataset_list() {
    zfs list -r -H -o name -S creation -S name "$1"
}

# $1: dataset
# $2: callback, return false to stop enumerating.
# $*: arguments for callback
# return: true if callback never failed.
dataset_enum() {
    local _dataset="$1"; shift
    local _callback="$1"; shift
    while read line; do
        if ! $_callback "$line" "$@"; then
            return 1
        fi
    done < <(zfs list -r -H -o name -S creation -S name "$_dataset")
}

# $1: dataset
dataset_is_staging() {
    [[ "${1#$_zfs_ds_stagings}" != "$1" ]]
}

# $1: dataset
dataset_is_snapshot() {
    [[ "${1#$_zfs_ds_snapshots}" != "$1" ]]
}

# $1: source dataset
# $2: destination dataset
dataset_move() {
    zfs rename -p "$1" "$2"
}

################
#
# snapshot id: ubuntu
#              the snapshot id is non-unique id
# versioned snapshot id: ubuntu:12.04
#                        versioned snapshot id must be unique
# normailized snapshot id: 3d0007ae-d9af-4898-ac9f-e0833a1571ff@ubuntu:1
#                          normaized snapshot id is the one paperbark used to
#                          map versioned snapshot id to zfs dataset, unique
#
################

# $1: tag ID
# $2: name of variable of tag name
# $3: name of variable of tag version
# $4: if tag ID has only tag name part, use this value as tag version
# return: true if version part of tag ID is not empty, false if not
snapshot_id_split() {
    eval $2="${1%:*}"
    eval $3="${1#${!2}}"
    eval $3="${!3#:}"
    if [[ -z "${!3}" ]]; then
        eval $3="$4"
    fi

    [[ "${!3}" ]]
}

# $1: snapshot id
snapshot_id_has_version() {
    [[ "${1%:*}" != "$1" ]]
}

# $1: snapshot id
# $2: snapshot version
# $3: variable name of final snapshot id
snapshot_id_add_version() {
    if ! snapshot_id_has_version "$1"; then
        eval $3="$1:$2"
    fi
}

# $1: snapshot id
# $2: variable name of normailzed snapshot id
snapshot_id_normalize() {
    snapshot_id_add_version "$1" latest $2
    if [[ "${!2#*@}" != "${!2}" ]]; then
        return
    fi

    if [[ -z "${_zfs_snap_id_fs_map[${!2}]}@${!2}" ]]; then
        return 1
    fi

    eval $2="${_zfs_snap_id_fs_map[${!2}]}@${!2}"
}

# $1: callback, return false to stop enumerating.
#    $1: fs
#    $2: snapshot id
# $*: arguments for callback
snapshot_enum() {
    local _callback="$1"; shift
    local _snapshot
    for _snapshot in ${_zfs_snaps[@]}; do
        if ! $_callback "${_snapshot%@*}" "${_snapshot#*@}" "$@"; then
            return 1
        fi
    done
}

# $1: source snapshot
# $2: destination snapshot
snapshot_rename() {
    zfs rename "$1" "$2"
}

# $1: fs
# $2: snapshot id
snapshot_create() {
    local _fs="$1"; shift
    local _snap_id="$1"; shift
    zfs snapshot "$_zfs_ds_snapshots/$_fs@$_snap_id" "$@"
}

# $1: snapshot id
# $2: variable name of dataset
snapshot_exists() {
    local _snap_id="$1"
    snapshot_id_add_version "$_snap_id" latest _snap_id
    if [[ -z "${_zfs_snap_id_fs_map[$_snap_id]}" ]]; then
        return 1
    fi

    if [[ "$2" ]]; then
        eval $2="$_zfs_ds_snapshots/${_zfs_snap_id_fs_map[$_snap_id]}@$1"
    fi
}

# $1: fs
# $2: variable name of dataset
snapshot_fs_exists() {
    if [[ -z "${_zfs_snap_fs_id_map[$1]}" ]]; then
        return 1
    fi

    if [[ "$2" ]]; then
        eval $2="${_zfs_snap_fs_id_map[$1]}:$1"
    fi
}

# $1: snapshot id
# $2: variable name of dataset
snapshot_to_dataset() {
    _snapshot_to_dataset() {
        if [[ "$1" == "$3" ]]; then
            eval $4="$_zfs_ds_snapshots/$2@$1"
            return 1
        fi
    }

    if snapshot_enum _snapshot_to_dataset "$@"; then
        return 1
    fi
}

# $1: variable of newly created staging filesystem
staging_create() {
    local _fs=$(uuidgen)
    dataset_create "$_zfs_ds_stagings/$_fs"
    eval $1="$_fs"
}

# $1: staging ID
staging_destroy() {
    dataset_destroy "$_zfs_ds_stagings/$1"
}

# $1: staging ID
# $2: optional. variable name of mount point
staging_mount() {
    local _staging_id="$1"; shift
    local _dest_mount_point="$(mktemp -d /tmp/paperbark-$$-XXXXXX)"
    dataset_mount "$_zfs_ds_stagings/$_staging_id" "$_dest_mount_point"
    if [[ "$2" ]]; then
        eval $2="$_dest_mount_point"
    fi
}

# $1: staging ID
# $2: variable name of dataset
staging_exists() {
    local _staging
    for _staging in "${_zfs_stags[@]}"; do
        if [[ "$1" != "$_staging" ]]; then
            continue
        fi

        if [[ "$2" ]]; then
            eval $2="$_zfs_ds_stagings/$1"
        fi

        return
    done

    return 1
}

# $1: callback, return false to stop enumerating.
#     $1: staging fs
# $*: arguments for callback
# return: true if callback never failed.
staging_enum() {
    local _callback="$1"; shift
    for fs in "${_zfs_stags[@]}"; do
        $_callback "$fs" "$@"
    done
}

# $1: filesystem
# $2: prefix
# $3: variable name of result dataset
staging_move_to_snapshots() {
    local _dest="$_zfs_ds_snapshots/$1"
    zfs rename -p "$dataset_staggins/$1" "$_dest"

    if [[ "$3" ]]; then
        eval $3="$_dest"
    fi
}

# $1: snapshot filesystem
# $2: optional. variable name of resulting dataset
snapshot_fs_to_stagings() {
    local _dest_dataset="$_zfs_ds_stagings/$1"
    dataset_move "$_zfs_ds_snapshots/$1" "$_dest_dataset"
    if [[ "$2" ]]; then
        eval $2="$_dest_dataset"
    fi
}

# $1: snapshot
snapshot_send() {
    sudo zfs send $_zfs_ds_snapshots/$1 | \
        pv -W -B 16M
}

# $1: from snapshot
# $2: to snapshot
snapshot_send_increment() {
    sudo zfs send -I $_zfs_ds_snapshots/$1 $_zfs_ds_snapshots/$2 | \
        pv -W -B 16M
}

# $1: progress callback
#     $1: normalized snapshot id
#     $2: progress
# $@: snapshot ids
snapshot_send_all() {
    if [[ 0 == $# ]]; then
        return
    fi

    local _callback="$1"; shift
    local _parent
    local _count=1

    $_callback "$1" "$_count"
    if ! snapshot_get_parent "$1" _parent; then
        snapshot_send "$1"
    else
        snapshot_send_increment "$_parent" "$1"
    fi
    _parent="$1"; shift

    while [[ 0 != $# ]]; do
        let _count++
        $_callback "$1" "$_count"
        snapshot_send_increment "$_parent" "$1"
        _parent="$1"; shift
    done
}

snapshot_receive() {
    sudo zfs recv -d $_zfs_pool_name
}

# $1: progress callback
#     $1: normalized snapshot id
#     $2: progress
# $@: expected normalized snpahost id to be received
snapshot_receive_all() {
    local _callback="$1"; shift
    local _count=1

    while [[ 0 != $# ]]; do
        $_callback "$1" "$_count"
        snapshot_receive
        let _count++
    done
}

# $1: normalized snapshot id
snapshot_has_parent() {
    [[ "${_zfs_snap_deps[$1]}" ]]
}

# $1: normalized snapshot id
# $2: variable name of parent snapshot
snapshot_get_parent() {
    if ! snapshot_has_parent "$1"; then
        return 1
    fi

    eval $2="${_zfs_snap_deps[$1]}"
}

# $1: normailzed snapshot id
# $2: variable name of resulting array of snapshots, start from oldest parent
snapshot_series_get() {
    local _snapshot="$1"
    local -a _snapshots=("$_snapshot")
    while snapshot_get_parent "$_snapshot" _snapshot; do
        _snapshots=("$_snapshot" "${_snapshots[@]}")
    done

    eval $2=\("${_snapshots[@]}"\)
}

# $1: variable name of tailored snapshot series
# $@: origin snapshot series
snapshot_series_request_diff() {
    local _result="$1"; shift

    echo "$@"

    local _line
    read _line

    eval $_result=\($_line\)
}

# $1: variable name of tailored result
snapshot_series_response_diff() {
    local _line
    read _line

    local _snapshots=($_line)
    for (( i=0; i<${#_snapshots[@]}; i++)); do
        if ! snapshot_exists "${_snapshots[$i]#*@}"; then
            break
        fi
    done

    echo ${_snapshots[@]:$i}

    eval $1=\("${_snapshots[@]:$i}"\)
}

# $1: snapshot id
# $2: variable name of staging filesystem
staging_clone_from_snapshot() {
    local _snap_id="$1"; shift
    local _snap_dataset
    snapshot_exists "$_snap_id" _snap_dataset
    local _fs=$(uuidgen)
    zfs clone "$_snap_dataset" "$_zfs_ds_stagings/$_fs"
    eval $1="$_fs"
}

# $1: staging fs
# $2: variale name of mount point
staging_mount() {
    local _mount_point=$(mktemp -d /tmp/$exec_file-$$-XXXXXX)
    cleanup_stack_push "rmdir '$_mount_point'"

    mount -t zfs "$_zfs_ds_stagings/$1" "$_mount_point"
    eval $2="${_mount_point}"
}

# $1: staging filesystem
# $2: variable name of resulting dataset
staging_move_to_snapshots() {
    local _dest_dataset="$_zfs_ds_snapshots/$1"
    dataset_move "$_zfs_ds_stagings/$1" "$_dest_dataset"
    if [[ "$2" ]]; then
        eval $2="$_dest_dataset"
    fi
}

zfs_cache_init() {
    if [[ "$_zfs_cache_inited" ]]; then
        return
    fi

    local _line
    while read _line; do
        local _fields=($_line)
        _fields[1]="${_fields[1]#$_zfs_ds_snapshots}"
        _fields[1]="${_fields[1]#/}"
        if [[ -z "${_fields[1]}" ]]; then
            continue
        fi

        if [[ 'snapshot' == "${_fields[0]}" ]]; then
            _zfs_snaps+=("${_fields[1]}")
            _zfs_snap_id_fs_map["${_fields[1]#*@}"]="${_fields[1]%@*}"
            _zfs_snap_fs_id_map["${_fields[1]%@*}"]+="${_fields[1]#*@}"
        elif [[ '-' != "${_fields[2]}" ]]; then
            local _snap_id="${_fields[1]}@${_zfs_snap_fs_id_map[${_fields[1]}]}"
            _zfs_snap_deps["$_snap_id"]="${_fields[2]#$_zfs_ds_snapshots/}"
        fi
    done < <(sudo zfs list -H -r -t all -o type,name,origin -S creation $_zfs_ds_snapshots)

    while read _line; do
        _fields=($_line)
        _fields[0]="${_fields[0]#$_zfs_ds_stagings}"
        _fields[0]="${_fields[0]#/}"
        if [[ -z "${_fields[0]}" ]]; then
            continue
        fi

        _zfs_stags+=("${_fields[0]}")
        if [[ '-' != "${_fields[1]}" ]]; then
            _zfs_stag_deps["${_fields[0]}"]="${_fields[1]#$_zfs_ds_snapshots/}"
        fi
    done < <(sudo zfs list -H -r -o name,origin -S creation $_zfs_ds_stagings)

    _zfs_cache_inited=yes
}

zfs_cache_reinit() {
    unset _zfs_cache_inited
    zfs_cache_init
}

dep_add zfs zpool mount

declare -g _zfs_cache_inited
declare -ga _zfs_snaps
declare -gA _zfs_snap_deps
declare -gA _zfs_snap_id_fs_map
declare -gA _zfs_snap_fs_id_map
declare -ga _zfs_stags
declare -gA _zfs_stag_deps
declare -g _zfs_ds_snapshots
declare -g _zfs_ds_stagings
declare -g _zfs_pool_name
