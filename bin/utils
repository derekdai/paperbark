#!/bin/bash
declare -a cleanup_jobs

log_trace() {
    echo -e " \e[90mT $@\e[0m" >&2
}

log_info() {
    echo -e " \e[32mI\e[0m $@" >&2
}

log_warn() {
    echo -e " \e[33mW\e[0m $@" >&2
}

log_error() {
    echo -e " \e[31mE\e[0m $@" >&2
}

cleanup_stack_init() {
    unset cleanup_jobs
}

cleanup_stack_push() {
    cleanup_jobs[${#cleanup_jobs[@]}]="$@"
}

cleanup_stack_pop_n_drop() {
    local -i index=${#cleanup_jobs[@]}-1
    unset cleanup_jobs[$index]
}

cleanup_stack_pop() {
    local -i index=${#cleanup_jobs[@]}-1
    log_trace ${cleanup_jobs[$index]}
    eval ${cleanup_jobs[$index]}
    unset cleanup_jobs[$index]
}

cleanup_stack_is_empty() {
    [[ 0 == ${#cleanup_jobs[@]} ]]
}

cleanup_stack_pop_all() {
    while ! cleanup_stack_is_empty; do
        cleanup_stack_pop
    done
}

fd_is_terminal() {
    [[ -t $1 ]]
}

stdin_is_terminal() {
    fd_is_terminal 0
}

stdout_is_terminal() {
    fd_is_terminal 1
}

stderr_is_terminal() {
    fd_is_terminal 2
}

# $1 - path
# $2 - size
create_sparse_file() {
    dd if=/dev/zero of="$1" bs=1 count=0 seek="$2" &>/dev/null
}

# $1: tag ID
# $2: name of variable of tag name
# $3: name of variable of tag version
# $4: if tag ID has only tag name part, use this value as tag version
# return: true if version part of tag ID is not empty, false if not
snapshot_id_split() {
    eval $2="${1%:*}"
    eval $3="${1#${!2}}"
    eval $3="${!3#:}"
    if [[ -z "${!3}" ]]; then
        eval $3="$4"
    fi

    [[ "${!3}" ]]
}

# $1: snapshot id
snapshot_id_has_version() {
    [[ "${1%:*}" != "$1" ]]
}

